# Cmake file for less
# by Pedro Oliva Rodrigues

cmake_minimum_required(VERSION 3.8)
project("gwsw-less" 
    VERSION 554 
    LANGUAGES C 
    HOMEPAGE_URL "http://www.greenwoodsoftware.com/less"
)

# Defaults
if(WIN32)
    set(EDIT_PGM_ "notepad")
    set(EDIT_PROTO_ "%E %g")
    if(NOT SYSDIR)
        set(SYSDIR "c:")
    endif()
else()
    set(EDIT_PGM_ "vi")
    set(EDIT_PROTO_ "%E ?lm+%lm. %g")
endif()

# User preferences
option(SECURE_COMPILE "If enabled, disables a bunch of features in order to be safe to run by unprivileged users." OFF)
option(CMD_HISTORY "Enable if you wish to allow keys to cycle through previous commands at prompts." ON)
option(HILITE_SEARCH "Enable if you wish to have search targets to be displayed in standout mode." ON)
set(EDIT_PGM ${EDIT_PGM_} CACHE STRING "Name of the default to be invoked by the 'v' command if EDITOR env. var. is not set")
set(EDIT_PROTO ${EDIT_PROTO_} CACHE STRING "The default editor prototype, if LESSEDIT is not set.")
option(GNU_OPTIONS "Enable if you wish to support the GNU-style command line options --help and --version." ON)
option(ONLY_RETURN "Enable if you want RETURN to be the only input which will continue past an error message. 
                    Otherwise, any key will continue past an error message." OFF)
set(LESSKEYFILE ".less" CACHE STRING "Filename of the default lesskey output file (in the HOME directory).")
set(LESSKEYFILE_SYS "sysless" CACHE STRING "Filename of the system-wide lesskey output file.")
set(DEF_LESSKEYINFILE ".lesskey" CACHE STRING "Filename of the default lesskey input (in the HOME directory).")
set(LESSHISTFILE ".lesshst" CACHE STRING "Filename of the history file (in the HOME directory).")

# targets
set(SRC main.c screen.c brac.c ch.c charset.c cmdbuf.c
    command.c cvt.c decode.c edit.c filename.c forwback.c
    ifile.c input.c jump.c line.c linenum.c
    lsystem.c mark.c optfunc.c option.c opttbl.c os.c
    output.c pattern.c position.c prompt.c search.c signal.c
    tags.c ttyin.c regexp.c)
    #help.c  funcs.h

add_executable(less ${SRC})
add_executable(lesskey lesskey.c)
add_executable(lessecho lessecho.c)

# sudo lib for common settings
add_library(common INTERFACE)
target_sources(common INTERFACE ${CMAKE_SOURCE_DIR}/version.c)
target_include_directories(common INTERFACE ${CMAKE_CURRENT_BINARY_DIR}) # for defines.h

target_link_libraries(less PRIVATE common)
target_link_libraries(lesskey PRIVATE common)
target_link_libraries(lessecho PRIVATE common)

# we may need to generate help.c, funcs.h
set(generated_files help.c funcs.h)
find_file(help_c_found  help.c  PATHS ${CMAKE_SOURCE_DIR} NO_DEFAULT_PATH)
find_file(funcs_h_found funcs.h PATHS ${CMAKE_SOURCE_DIR} NO_DEFAULT_PATH)

if(NOT help_c_found OR NOT funcs_h_found)
    message(CHECK_START " " "Generating files (${generated_files})")

    find_package(Perl REQUIRED)

    if(NOT help_c_found)
        message(CHECK_START "  " "Generating help.c")
        execute_process(
            COMMAND ${PERL_EXECUTABLE} mkhelp.pl
            WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
            INPUT_FILE less.hlp
            OUTPUT_FILE help.c
            RESULT_VARIABLE gen
        )
        if(gen EQUAL 0)
            message(CHECK_PASS "  " "ok")
        else()
            message(CHECK_FAIL "  " "fail")
        endif()
    endif()

    if(NOT funcs_h_found)
        message(CHECK_START "  " "Generating funcs.h")
        execute_process(
            COMMAND ${PERL_EXECUTABLE} mkfuncs.pl ${SRC} help.c
            WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
            OUTPUT_FILE funcs.h
            RESULT_VARIABLE gen
        )
        if(gen EQUAL 0)
            message(CHECK_PASS "  " "ok")
        else()
            message(CHECK_FAIL "  " "fail")
        endif()
    endif()

    if((EXISTS help.c) AND (EXISTS funcs.h))
        message(CHECK_PASS "  " "ok")
    else()
        message(CHECK_FAIL "  " "fail")
    endif()
    
endif()

# help.c, funcs.h exists at this point
target_sources(less PRIVATE help.c funcs.h)


# find terminal libraries
find_package(Curses) # curses or ncurses
find_library(TINFO_LIB NAMES tinfo libtinfo)
find_library(TERMCAP_LIB names termcap libtermcap)

if(WIN32)
    set(TERMINAL_API WindowsConsole)
elseif(TINFO_LIB)
    set(TERMINAL_API tinfo)
    target_link_libraries(less PRIVATE ${TINFO_LIB})
elseif(CURSES_FOUND)
    target_include_directories(less PRIVATE ${CURSES_INCLUDE_DIRS})
    set(TERMINAL_API curses)
    target_link_libraries(less PRIVATE ${CURSES_LIBRARIES})
elseif(TERMCAP_LIB)
    set(TERMINAL_API termcap)
    target_link_libraries(less PRIVATE ${TERMCAP_LIB})
else()
    set(TERMINAL_API NOTFOUND)
endif()

if(NOT TERMINAL_API)
    message(SEND_ERROR "Cannot find terminal libraries")
else()
    message(STATUS "using ${TERMINAL_API}")
endif()

# dependency detection
include(CheckIncludeFiles)
include(CheckTypeSize)
include(CheckSymbolExists)
check_include_files("langinfo.h"   HAVE_LANGINFO)
check_include_files("sys/ioctl.h"  HAVE_SYS_IOCTL_H)
check_include_files("sys/ptem.h"   HAVE_SYS_PTEM_H)
check_include_files("sys/stream.h" HAVE_SYS_STREAM_H)
check_include_files("termios.h" HAVE_TERMIOS_H)
check_include_files("termio.h"  HAVE_TERMIO_H)
check_include_files("termcap.h" HAVE_TERMCAP_H)

list(APPEND CMAKE_EXTRA_INCLUDE_FILES "signal.h")
check_type_size("(sigset_t*)0" SIGSET_T)
check_symbol_exists(sigemptyset "signal.h" HAVE_SIGEMPTYSET)

configure_file(defines.cmake.in defines.h)